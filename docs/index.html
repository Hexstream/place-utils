<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8" />
    <link rel="canonical" href="https://www.hexstreamsoft.com/libraries/place-utils/" />
    <meta name="author" content="Jean-Philippe Paradis" />
    <link rel="author" href="https://abc.hexstream.xyz/" />
    <link rel="license" href="https://www.hexstreamsoft.com/UNLICENSE" />
    <meta name="description" content="Provides a few utilities relating to setfable places. Notably provides SETF-EXPANDERLET (and WITH-RESOLVED-PLACES, which uses it)." />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>place-utils | Libraries | HexstreamSoft</title>
    <link href="https://www.hexstreamsoft.com/css/global.css" rel="stylesheet" type="text/css" />
    <link href="https://www.hexstreamsoft.com/libraries/libraries.css" rel="stylesheet" type="text/css" />
    <script src="https://global.hexstream.dev/scripts/arrows-madness.mjs" type="module"></script>
    <script src="https://www.hexstreamsoft.com/libraries/libraries.mjs" type="module"></script>
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@HexstreamSoft" />
    <meta name="twitter:title" content="place-utils" />
    <meta name="twitter:description" content="Provides a few utilities relating to setfable places." />
  </head>

  <body>

    <nav id="top-nav">

      <div class="main">

        <div class="breadcrumbs">
          <a href="https://www.hexstreamsoft.com/">HexstreamSoft</a>
          <span class="crumb"><span class="s"> » </span><a href="https://www.hexstreamsoft.com/libraries/">Libraries</a></span>
          <span class="crumb"><span class="s"> » </span><a class="here">place-utils</a></span>
        </div>

        <nav class="tabs" id="meta-nav">
          <ul>
            <li><a class="github" href="https://github.com/Hexstream/place-utils"><span>See on GitHub</span></a></li>
          </ul>
        </nav>

      </div>

      <p id="last-updated"><span>This page was last updated on </span><time datetime="2020-11-21">21 november 2020</time><span>.</span></p>

    </nav>

    <main>

      <header id="page-header">
        <h1>place-utils</h1>
      </header>

      <div class="tags contains-groups">
        <div class="group prominent">
          <span class="tag hv license">
            <span class="h">License<span>:</span></span>
            <span class="v">Public Domain</span>
          </span>
          <span class="s">, </span>
          <span class="tag hv quicklisp">
            <span class="h">Load it with Quicklisp<span>:</span></span>
            <code class="v">(ql:quickload "place-utils")</code>
          </span>
        </div>
        <div class="group">
          <span class="tag hv">
            <span class="h">Library type<span>:</span></span>
            <span class="v">Thematic utilities</span>
          </span>
          <span class="s">, </span>
          <span class="tag hv">
            <span class="h">Project complexity<span>:</span></span>
            <span class="v">Simple</span>
          </span>
        </div>
      </div>

      <nav class="tabs" id="further-info">
        <ul>
          <li><a href="https://www.hexstreamsoft.com/libraries/releases/latest-versions/#place-utils">Latest release</a></li>
          <li><a href="https://www.hexstreamsoft.com/libraries/dependencies/#place-utils">Dependencies</a></li>
        </ul>
        <ul>
          <li><a href="https://www.hexstreamsoft.com/libraries/external-pages-xref/#place-utils">External library pages</a></li>
        </ul>
      </nav>

      <section id="introduction">

        <p><cite class="relevant">place-utils</cite> provides a few utilities relating to setfable places.</p>

      </section>

      <nav class="tabs">
        <ul>
          <li><a href="#setf-expanderlet">setf-expanderlet</a></li>
          <li><a href="#with-resolved-places">with-resolved-places</a></li>
          <li><a href="#updatef">updatef</a></li>
          <li><a href="#bulkf">bulkf</a></li>
          <li><a href="#cachef">cachef</a></li>
          <li><a href="#oldf">oldf</a></li>
          <li><a href="#readf">readf</a></li>
          <li><a href="#tracef">tracef</a></li>
        </ul>
      </nav>

      <section id="setf-expanderlet">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#setf-expanderlet" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-utils</a>
            <span class="crumb"><span class="s"> » </span><a class="here">setf-expanderlet</a></span>
          </span>
        </h1>

        <p class="description">Introduce local setf-expanders.</p>

        <dl>

          <dt><pre>Macro <code class="relevant">setf-expanderlet</code> (&amp;rest <var>bindings</var>) &amp;body <var>body</var>
  &rArr; <var>results</var></pre></dt>

          <dd>
            <p><code class="relevant">setf-expanderlet</code> introduces local setf-expanders. This opens possibilities for more complex local setf-expanders than can be handled by Common Lisp's built-in support for local setf functions (which must evaluate all their arguments once from left to right and can only accept one new value at a time).</p>
            <p><code class="relevant">setf-expanderlet</code> is to <code><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_3.htm">define-setf-expander</a></code> as <code><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">macrolet</a></code> is to <code><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defmac.htm">defmacro</a></code>. The <var>bindings</var> of <code class="relevant">setf-expanderlet</code> have much the same semantics as their counterparts in <code><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm">macrolet</a></code>, except the job of each expander is to return a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/05_aab.htm">setf expansion</a> (5 values), not a normal expansion (a form).</p>
            <p>As an example of what <code class="relevant">setf-expanderlet</code> can let one accomplish, <code class="relevant">with-resolved-places</code> is trivially implemented in terms of it.</p>
            <p><b>Implementation note:</b> Surprisingly enough, this implementation of <code class="relevant">setf-expanderlet</code> is written fully portably. As far as I can tell, the only caveat is that the name of the local setf-expander is unconditionally made a local macro. This macro, if used in a non-place context, simply expands to a form that evaluates the subforms and then reads the place.</p>
            <p>In contrast, "real" setf-expanders as defined by <code><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_3.htm">define-setf-expander</a></code> don't affect the semantics of the operator in non-place contexts, which is useful if the operator is a function. However, if the original operator is simple enough that it's implemented as a function, you can probably just use a local setf function anyway so I don't think the aforementioned caveat is very important.</p>
          </dd>
        </dl>

      </section>

      <section id="with-resolved-places">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#with-resolved-places" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-utils</a>
            <span class="crumb"><span class="s"> » </span><a class="here">with-resolved-places</a></span>
          </span>
        </h1>

        <p class="description">Evaluate subforms once, then access repeatedly safely.</p>

        <dl>
          <dt><pre>Macro <code class="relevant">with-resolved-places</code> (&amp;rest <var>bindings</var>) &amp;body <var>body</var>
  &rArr; <var>results</var></pre></dt>
          <dd>
            <p>Each <var>binding</var> is of the form <code class="common-lisp">(<var>resolved-place</var> <var>unresolved-place</var>)</code>.</p>
            <p>At the time <code class="relevant">with-resolved-places</code> is entered, the subforms of each <var>unresolved-place</var> are evaluated and bound to their temporary variables. Within <var>body</var> (an implicit <code>progn</code>), each <var>resolved-place</var> can be used to access (read and/or write) the corresponding <var>unresolved-place</var>, perhaps repeatedly, without evaluating the subforms again.</p>
            <div class="scroll">
              <pre class="example"><code class="common-lisp">(let* ((<var>my-list</var> (list 0 1 2))
       (<var>my-other-list</var> <var>my-list</var>))
  (<code class="relevant">with-resolved-places</code> ((<var>second</var> (second (princ <var>my-list</var>))))
    (setf <var>my-list</var> nil <var>second</var> 8)
    (incf <var>second</var> 2)
    (list <var>my-list</var> <var>my-other-list</var> <var>second</var>)))

-| (0 1 2)
&rArr; (NIL (0 10 2) 10)</code></pre>
            </div>
            <p><a href="http://www.lispworks.com/documentation/HyperSpec/Body/05_aaa.htm">CLHS 5.1.1.1 Evaluation of Subforms to Places</a></p>
            <p>In the absence of <code class="relevant">with-resolved-places</code>, in situations where multiple evaluation of subforms for different accesses is not desirable, one would traditionally bind the results of the evaluation of the troublesome subforms (with <code>let</code> or <code>let*</code>) in an ad-hoc way on an as-needed basis, manually replicating part of the job of <a href="http://www.lispworks.com/documentation/HyperSpec/Body/05_aab.htm">setf expanders</a>.</p>
          </dd>
        </dl>

      </section>

      <section id="updatef">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#updatef" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-utils</a>
            <span class="crumb"><span class="s"> » </span><a class="here">updatef</a></span>
          </span>
        </h1>

        <p class="description">Like setf, except supply update functions (to be called with old values) instead of new values.</p>

        <dl>
          <dt><pre>Modify Macro <code class="relevant">updatef</code> &amp;rest <var>places-and-update-functions</var>
  &rArr; <var>results</var></pre></dt>
          <dd>
            <p><code class="relevant">updatef</code> is exactly like <code>setf</code>, except that instead of directly providing new values to store into the place, one provides update functions that will be called with the corresponding old value. Each store variable is bound to the result of calling the corresponding update function with the old value, then the storing form is evaluated.</p>
            <div class="scroll">
              <pre class="example"><code class="common-lisp">(defun double (<var>number</var>) (* <var>number</var> 2))

(let ((<var>a</var> 2) (<var>b</var> 8))
  (<code class="relevant">updatef</code> (values <var>a</var> <var>b</var>) #'double)
  (values <var>a</var> <var>b</var>))

&rArr; 4, NIL</code></pre>
              </div>
            <div class="scroll">
              <pre class="example"><code class="common-lisp">(let ((<var>a</var> 2) (<var>b</var> 8))
  (<code class="relevant">updatef</code> <var>a</var> #'1+
           <var>a</var> #'double
           <var>b</var> #'-)
  (values <var>a</var> <var>b</var>))

&rArr; 6, -8</code></pre>
            </div>

            <div class="scroll">
              <pre class="example"><code class="common-lisp">(let ((<var>a</var> (vector 1 2)))
  (<code class="relevant">updatef</code> (aref (print <var>a</var>) (print 1))
           (print #'double))
  <var>a</var>)
  -| #(1 2)
  -| 1
  -| #&lt;FUNCTION DOUBLE&gt;

&rArr; #(1 4)</code></pre>
            </div>

        </dd>
      </dl>

      </section>

      <section id="bulkf">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#bulkf" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-utils</a>
            <span class="crumb"><span class="s"> » </span><a class="here">bulkf</a></span>
          </span>
        </h1>

        <p class="description">Flexible mass updating of places. An update function receives the old values as arguments and returns the values to write back as multiple values.</p>

        <nav class="tabs">
          <ul>
            <li><a href="#bulkf_description">Description</a></li>
            <li><a href="#bulkf_examples">Examples</a></li>
          </ul>
        </nav>

        <section id="bulkf_description">

          <h1 class="breadcrumbs-bar">
            <span class="section-relative-nav">
              <a href="#bulkf_description" class="anchor">⚓</a>
            </span>
            <span class="breadcrumbs">
              <a href="#">place-utils</a>
              <span class="crumb"><span class="s"> » </span><a href="#bulkf">bulkf</a></span>
              <span class="crumb"><span class="s"> » </span><a class="here">Description</a></span>
            </span>
          </h1>

          <dl>
            <dt><pre>Modify Macro <code class="relevant">bulkf</code> <var>update-function-form</var> &amp;rest <var>mode-markers-and-items</var>
  &rArr; <var>results</var></pre></dt>
            <dd>
              <p><code class="relevant">bulkf</code> allows mass updating of places.</p>
              <p><var>update-function-form</var> is evaluated first to produce <var>update-function</var>. The arguments and return values of this function depend on <var>mode-markers-and-items</var> and are described below.</p>
              <p><var>mode-markers-and-items</var> is a list of <var>mode-markers</var> and <var>items</var> to be processed from left to right at macroexpansion-time. A <var>mode-marker</var> is one of the symbols <code class="relevant marker">:access</code>, <code class="relevant marker">:read</code>, <code class="relevant marker">:write</code> or <code class="relevant marker">:pass</code>. Any other form is an <var>item</var>. Whenever a <var>mode-marker</var> is encountered, the mode with that name becomes the current mode and remains so until the next <var>mode-marker</var>. The current mode at the start of <var>mode-markers-and-items</var> is <code class="relevant marker">:access</code> mode. There are 4 different types of <var>items</var>, corresponding to the 4 different modes that can be the current mode at the time the <var>item</var> is encountered. Here are the semantics of each type of item:</p>

              <dl>

                <dt><dfn><code class="relevant marker">:access</code></dfn></dt>
                <dd><p><var>item</var> is a place that will be both read from and written to. At runtime, the subforms of the place are evaluated and the place is read. The primary value is contributed as an additional argument to <var>update-function</var>. <var>update-function</var> also returns an additional value that will be written back into the place (reusing the temporary variables bound to the results of the subforms).</p></dd>

                <dt><dfn><code class="relevant marker">:read</code></dfn></dt>
                <dd><p><var>item</var> is a place that will be read from. At runtime, the subforms of the place are evaluated and the place is read. The primary value is contributed as an additional argument to <var>update-function</var>.</p></dd>

                <dt><dfn><code class="relevant marker">:write</code></dfn></dt>
                <dd><p><var>item</var> is a place that will be written to. <var>update-function</var> returns an additional value that will be written into the place. The evaluation of the subforms of the place happens at the same time as it would have happened if the place had been read from.</p></dd>

                <dt><dfn><code class="relevant marker">:pass</code></dfn></dt>
                <dd><p><var>item</var> is a form to be evaluated normally. Its primary value is passed as an additional argument to <var>update-function</var>.</p></dd>

              </dl>

              <p>If <var>update-function</var> returns more values than there are places to write to (<code class="relevant marker">:access</code> and <code class="relevant marker">:write</code> <var>items</var>), the additional values are ignored. If it returns less values than there are of these places, the remaining ones are set to <code>nil</code>. <code class="relevant">bulkf</code> returns the values that were written into these places. This might be more or less values than were returned by <var>update-function</var>. If a place to be written to has more than one store variable, the remaining such variables are set to <code>nil</code> prior to evaluation of the storing form.</p>

              <p><code class="relevant">bulkf</code> accepts an optional unevaluated argument before <var>update-function-form</var> (as very first argument). This must be the symbol <code>funcall</code> or <code>apply</code> and determines which operator will be used to call the <var>update-function</var> with its arguments. The default is <code>funcall</code>, which is expected to be used an overwhelming majority of the time. This is the reason this argument has not been made a normal required parameter.</p>

            </dd>

          </dl>
        </section>

        <section id="bulkf_examples">

          <h1 class="breadcrumbs-bar">
            <span class="section-relative-nav">
              <a href="#bulkf_examples" class="anchor">⚓</a>
            </span>
            <span class="breadcrumbs">
              <a href="#">place-utils</a>
              <span class="crumb"><span class="s"> » </span><a href="#bulkf">bulkf</a></span>
              <span class="crumb"><span class="s"> » </span><a class="here">Examples</a></span>
            </span>
          </h1>

          <p><code class="relevant">bulkf</code> is very versatile and can be used to easily implement many different types of modify macros. Here are just a few examples:</p>

          <div class="scroll">
            <pre class="example"><code class="common-lisp">(<code>defun</code> <var>bulkf-transfer</var> (<var>quantity</var> <var>source</var> <var>destination</var>)
  (<code>values</code> (<code>-</code> <var>source</var> <var>quantity</var>)
          (<code>+</code> <var>destination</var> <var>quantity</var>)))

(<code>defmacro</code> <var>transferf</var> (<var>quantity</var> <var>source</var> <var>destination</var>)
  `(<code class="relevant">bulkf</code> #'<var>bulkf-transfer</var>
          <code class="relevant marker">:pass</code> ,<var>quantity</var>
          <code class="relevant marker">:access</code> ,<var>source</var> ,<var>destination</var>))

(let ((<var>account-amounts</var> (<code>list</code> 35 90)))
  (<code>multiple-value-call</code> #'<code>values</code>
    (<var>transferf</var> 10
               (<code>first</code> <var>account-amounts</var>)
               (<code>second</code> <var>account-amounts</var>))
    <var>account-amounts</var>))
&rArr; 25, 100, (25 100)</code></pre>
          </div>

          <div class="scroll">
            <pre class="example"><code class="common-lisp">(<code>defun</code> <var>bulkf-init</var> (<var>value</var> <var>number-of-places</var>)
  (<code>values-list</code> (<code>make-list</code> <var>number-of-places</var>
                          :initial-element <var>value</var>)))

(<code>defmacro</code> <var>initf</var> (<var>value</var> &amp;rest <var>places</var>)
  `(<code class="relevant">bulkf</code> #'<var>bulkf-init</var>
          <code class="relevant marker">:pass</code> ,<var>value</var> ,(<code>length</code> <var>places</var>)
          <code class="relevant marker">:write</code> ,@<var>places</var>))

(<code>let</code> (<var>a</var> <var>b</var> (<var>c</var> (<code>make-list</code> 3 :initial-element nil)))
  (<var>initf</var> 0 <var>a</var> <var>b</var> (<code>second</code> <var>c</var>))
  (<code>values</code> <var>a</var> <var>b</var> <var>c</var>))
&rArr; 0, 0, (NIL 0 NIL)</code></pre>
          </div>

          <div class="scroll">
            <pre class="example"><code class="common-lisp">(<code>defun</code> <var>bulkf-spread</var> (<var>spread-function</var> <var>sum-function</var>
                     &amp;rest <var>place-values</var>)
  (<code>values-list</code>
   (let ((<var>number-of-places</var> (length <var>place-values</var>)))
     (<code>make-list</code> <var>number-of-places</var>
                :initial-element
                (<code>funcall</code> <var>spread-function</var>
                         (<code>apply</code> <var>sum-function</var> <var>place-values</var>)
                         <var>number-of-places</var>)))))

(<code>defmacro</code> <var>spreadf</var> (<var>spread-function</var> <var>sum-function</var> &amp;rest <var>places</var>)
  `(<code class="relevant">bulkf</code> #'<var>bulkf-spread</var> <code class="relevant marker">:pass</code> ,<var>spread-function</var> ,<var>sum-function</var>
          <code class="relevant marker">:access</code> ,@<var>places</var>))

(<code>let</code> ((<var>a</var> 5) (<var>b</var> (<code>list</code> 10 18 20)))
  (<var>spreadf</var> #'<code>/</code> #'<code>+</code> <var>a</var> (<code>first</code> <var>b</var>) (<code>second</code> <var>b</var>))
  (<code>values</code> <var>a</var> <var>b</var>))
&rArr; 11, (11 11 20)

(<code>let</code> ((<var>a</var> 2) (<var>b</var> (<code>list</code> 2 4 8)))
  (<var>spreadf</var> #'<code>*</code> #'<code>*</code> <var>a</var> (<code>first</code> <var>b</var>) (<code>second</code> <var>b</var>) (<code>third</code> <var>b</var>))
  (<code>values</code> <var>a</var> <var>b</var>))
&rArr; 512, (512, 512, 512)</code></pre>
          </div>

          <div class="scroll">
            <pre class="example"><code class="common-lisp">(<code>defun</code> <var>bulkf-map</var> (<var>function</var> &amp;rest <var>place-values</var>)
  (<code>values-list</code> (<code>mapcar</code> <var>function</var> <var>place-values</var>)))

(<code>defmacro</code> <var>mapf</var> (<var>function</var> &amp;rest <var>places</var>)
  `(<code class="relevant">bulkf</code> #'<var>bulkf-map</var> <code class="relevant marker">:pass</code> ,<var>function</var> <code class="relevant marker">:access</code> ,@<var>places</var>))

(<code>let</code> ((<var>a</var> 0) (<var>b</var> 5) (<var>c</var> (<code>list</code> 10 15)))
  (<code>values</code> (<code>multiple-value-list</code> (<var>mapf</var> #'<code>1+</code> <var>a</var> <var>b</var> (<code>second</code> <var>c</var>)))
          <var>a</var> <var>b</var> <var>c</var>))
&rArr; (1 6 16), 1, 6, (10 16)</code></pre>
          </div>

          <div class="scroll">
            <pre class="example"><code class="common-lisp">(<code>defun</code> <var>bulkf-steal</var> (<var>sum-function</var> <var>steal-function</var>
                    <var>initial-assets</var> &amp;rest <var>target-assets</var>)
  (<code>let</code> (<var>stolen</var> <var>leftovers</var>)
    (<code>mapc</code> (<code>lambda</code> (<var>assets</var>)
            (<code>multiple-value-bind</code> (<var>steal</var> <var>leftover</var>)
                (<code>funcall</code> <var>steal-function</var> <var>assets</var>)
              (<code>push</code> <var>steal</var> <var>stolen</var>)
              (<code>push</code> <var>leftover</var> <var>leftovers</var>)))
          <var>target-assets</var>)
    (<code>values-list</code>
     (<code>cons</code> (<code>apply</code> <var>sum-function</var>
                  (<code>cons</code> <var>initial-assets</var> (<code>nreverse</code> <var>stolen</var>)))
           (<code>nreverse</code> <var>leftovers</var>)))))

(<code>defmacro</code> <var>stealf</var> (<var>sum-function</var> <var>steal-function</var> <var>hideout</var> &amp;rest <var>targets</var>)
  `(<code class="relevant">bulkf</code> #'<var>bulkf-steal</var> <code class="relevant marker">:pass</code> ,<var>sum-function</var> ,<var>steal-function</var>
          <code class="relevant marker">:access</code> ,<var>hideout</var> ,@<var>targets</var>))

(<code>let</code> ((<var>cave</var> :initial-assets)
      (<var>museum</var> '(:paintings :collection))
      (<var>house</var> 20000)
      (<var>triplex</var> (list :nothing-valuable :random-stuff 400)))
  (<var>stealf</var> #'<code>list</code>
          (<code>lambda</code> (<var>assets</var>)
            (if (eq <var>assets</var> :nothing-valuable)
                (values nil <var>assets</var>)
                (values <var>assets</var> (<code>if</code> (<code>numberp</code> <var>assets</var>) 0 nil))))
          <var>cave</var> <var>museum</var> <var>house</var> (<code>first</code> <var>triplex</var>) (<code>second</code> <var>triplex</var>) (<code>third</code> <var>triplex</var>))
  (<code>values</code> <var>cave</var> <var>museum</var> <var>house</var> <var>triplex</var>))
&rArr;
(:INITIAL-ASSETS (:PAINTINGS :COLLECTION) 20000 NIL :RANDOM-STUFF 400)
NIL
0
(:NOTHING-VALUABLE NIL 0)</code></pre>
          </div>

        </section>

        <nav class="end-of-section-indicator">
          <a href="#bulkf">
            "<span>bulkf</span>" end.
          </a>
        </nav>

      </section>

      <section id="cachef">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#cachef" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-utils</a>
            <span class="crumb"><span class="s"> » </span><a class="here">cachef</a></span>
          </span>
        </h1>

        <p class="description">Compute the value of a place only when it's first read.</p>

        <dl>
          <dt><pre>Accessor Modifier <code class="relevant">cachef</code> <var>cachedp-place</var> <var>cache-place</var> <var>init-form</var>
                         &amp;key <var>test</var> <var>new-cachedp</var> <var>init-form-evaluates-to</var></pre></dt>
          <dd>
            <p><code class="relevant">cachef</code> allows one to compute the value of a place only when it's first read.</p>
            <p>The consequences are undefined if <var>cachedp-place</var> or <var>cache-place</var> involves more than one value. I initially planned to support multiple values everywhere but finally decided that it's overkill. An implementation is permitted to extend the semantics to support multiple values. <small>(With that out of the way, the rest of the description will be simpler.)</small></p>
            <p><code class="relevant">cachef</code> has two major modes of operation: <a href="#cachef_ICC-eval">"in-cache cachedp" (ICC) mode</a> and <a href="#cachef_OOCC-eval">"out-of-cache cachedp" (OOCC) mode</a>. The former is selected if <var>cachedp-place</var> is <code>nil</code> at macroexpansion-time, else the latter is selected.</p>
            <p>Let's first describe the semantics of the arguments without regard to their order in the lambda list nor the time at which they're evaluated. After, we'll see the order of evaluation step-by-step for both modes.</p>

            <p>An important notion of <code class="relevant">cachef</code> is, of course, how it tests to see if the cache is full or empty. The way this is done is to call <var>test-function</var> (the result of evaluating <var>test</var>) with an appropriate argument. In <a href="#cachef_ICC-eval">ICC mode</a>, <var>test-function</var> is called with the value of <var>cache-place</var>. In <a href="#cachef_OOCC-eval">OOCC mode</a>, it's called with the value of <var>cachedp-place</var>. Either way, the cache is considered full or empty if <var>test-function</var> returns generalized <code>true</code> or <code>false</code>, respectively.</p>

            <p>Whenever <var>cache-place</var> is about to be read, if the cache is empty, it's first filled with <var>init-form</var>. The semantics of <var>init-form</var> are described below. In <a href="#cachef_ICC-eval">ICC mode</a>, it's assumed that the new value tests as a full cache (else, the cache will be &ldquo;re-filled&rdquo; next time). In <a href="#cachef_OOCC-eval">OOCC mode</a>, whenever the cache is written to (regardless of if this write results from a cache-miss or a direct request), <var>cachedp-place</var> is set to the value of <var>new-cachedp</var>. It's an error to supply <var>new-cachedp</var> in <a href="#cachef_ICC-eval">ICC mode</a>, as it's not needed (<var>init-form</var> somewhat fulfills its role).</p>
            <p><var>init-form</var> is a form that either evaluates to the values to store into the cache, or to a function that performs such an evaluation, depending on whether <var>init-form-evaluates-to</var> is <code class="relevant marker">:value</code> or <code class="relevant marker">:function</code> (at macroexpansion-time), respectively. The former is convenient in simple scenarios where there is no &ldquo;distance&rdquo; between the evaluation of subforms and access to the cache, while the latter is more likely to be correct in more complex cases (such as when used with <code class="relevant">with-resolved-places</code>) by virtue of capturing the lexical context in which the subforms are evaluated instead of whichever one is current at the place in the code where the cache is accessed.</p>
            <p><var>cache-place</var> holds the cached value if the cache is full, or a placeholder value if the cache is empty. In <a href="#cachef_ICC-eval">ICC mode</a>, this value itself is tested to see if the cache is full or empty. For instance, a value of <code>nil</code> might indicate an empty cache, while any other value indicates a full cache (this is the default behavior, as <var>test</var> defaults to <code class="common-lisp">'#'identity</code>). Of course, in this case there's no way to distinguish between an empty cache and a full cache containing <code>nil</code>. A possible workaround would be to use a gensym as a "cache-is-empty" marker, however this might not be performance-friendly. For instance, if the cache only ever contains values of type <code class="common-lisp">(mod 1024)</code>, one might want to declare this type, but a gensym is not valid. One would have to declare a type of <code class="common-lisp">(or symbol (mod 1024))</code>. In this case, <a href="#cachef_OOCC-eval">OOCC mode</a> might be preferable, as the <var>cachedp-place</var> can be declared to be of type <code>boolean</code> (for example) while the <var>cache-place</var> can be declared to be of the exact type of values that might be stored in the cache.</p>

            <section id="cachef_ICC-eval">

              <h1 class="breadcrumbs-bar">
                <span class="section-relative-nav">
                  <a href="#cachef_ICC-eval" class="anchor">⚓</a>
                </span>
                <span class="breadcrumbs">
                  <a href="#">place-utils</a>
                  <span class="crumb"><span class="s"> » </span><a href="#cachef">cachef</a></span>
                  <span class="crumb"><span class="s"> » </span><a class="here">In-Cache-Cachedp (ICC) evaluation order</a></span>
                </span>
              </h1>

              <p>At the time subforms of the <code class="relevant">cachef</code> place are evaluated:</p>
              <ol>
                <li>If <var>init-form-evaluates-to</var> is <code>:function</code>, <var>init-form</var> is evaluated to produce <var>init-form-function</var>.</li>
                <li><var>test</var> is evaluated to produce <var>test-function</var>.</li>
              </ol>
              <p>At the time an attempt is made to read the value of the <code class="relevant">cachef</code> place:</p>
              <ol>
                <li><var>test-function</var> is called with the value of <var>cache-place</var>, producing <var>fullp</var>.</li>
                <li>If <var>fullp</var> is generalized true, the value of <var>cache-place</var> that was read in step 1 is simply returned. Else, <var>cache-place</var> is assigned the result of evaluating the <var>init-form</var> and that value is returned.</li>
              </ol>
              <p>At the time a value is assigned to the <code class="relevant">cachef</code> place, the value is simply stored into <var>cache-place</var> directly and it's assumed that calling <var>test-function</var> with this value the next time the <code class="relevant">cachef</code> place is read will return generalized true, indicating a full cache.</p>
            </section>

            <section id="cachef_OOCC-eval">

              <h1 class="breadcrumbs-bar">
                <span class="section-relative-nav">
                  <a href="#cachef_OOCC-eval" class="anchor">⚓</a>
                </span>
                <span class="breadcrumbs">
                  <a href="#">place-utils</a>
                  <span class="crumb"><span class="s"> » </span><a href="#cachef">cachef</a></span>
                  <span class="crumb"><span class="s"> » </span><a class="here">Out-Of-Cache-Cachedp (OOCC) evaluation order</a></span>
                </span>
              </h1>

              <p>At the time subforms of the <code class="relevant">cachef</code> place are evaluated:</p>
              <ol>
                <li>The subforms of <var>cachedp-place</var> are evaluated.</li>
                <li>The subforms of <var>cache-place</var> are evaluated.</li>
                <li>If <var>init-form-evaluates-to</var> is <code class="relevant marker">:function</code>, <var>init-form</var> is evaluated to produce <var>init-form-function</var>.</li>
                <li><var>test</var> and <var>new-cachedp</var> are evaluated in the order they appear.</li>
              </ol>
              <p>At the time an attempt is made to read the value of the <code class="relevant">cachef</code> place:</p>
              <ol>
                <li><var>test-function</var> is called with the value of <var>cachedp-place</var>, producing <var>fullp</var>.</li>
                <li>If <var>fullp</var> is generalized true, The value of <var>cache-place</var> that was read in step 1 is simply returned. Else, <var>cache-place</var> is assigned the result of evaluating the <var>init-form</var> and that value is returned.</li>
              </ol>
              <p>At the time a value is assigned to the <code class="relevant">cachef</code> place, the value is stored into <var>cache-place</var> and the result of evaluating <var>new-cachedp</var> (that was evaluated along with the subforms previously) is stored into <var>cachedp-place</var>.</p>
            </section>

            <section id="cachef_examples">

              <h1 class="breadcrumbs-bar">
                <span class="section-relative-nav">
                  <a href="#cachef_examples" class="anchor">⚓</a>
                </span>
                <span class="breadcrumbs">
                  <a href="#">place-utils</a>
                  <span class="crumb"><span class="s"> » </span><a href="#cachef">cachef</a></span>
                  <span class="crumb"><span class="s"> » </span><a class="here">Examples</a></span>
                </span>
              </h1>

              <div class="scroll">
                <pre class="example"><code class="common-lisp">(<code>let</code> ((<var>cache</var> "cached-string"))
  (<code>incf</code> (<code class="relevant">cachef</code> nil <var>cache</var> 0 :test #'<code>numberp</code>) (<code>print</code> (<code>+</code> 5 2)))
  <var>cache</var>)
-| 7
&rArr; 7</code></pre>
              </div>

              <div class="scroll">
                <pre class="example"><code class="common-lisp">(<code>let</code> ((<var>cache</var> 20))
  (<code>incf</code> (<code class="relevant">cachef</code> nil <var>cache</var> 0 :test #'<code>numberp</code>) (<code>print</code> (<code>+</code> 5 2)))
  <var>cache</var>)
-| 7
&rArr; 27</code></pre>
              </div>

              <div class="scroll">
                <pre class="example"><code class="common-lisp">(<code>let</code> ((<var>values</var> (<code>list</code> :empty :placeholder)))
  (<code class="relevant">cachef</code> (<code>first</code> <var>values</var>) (<code>second</code> (<code>print</code> <var>values</var>))
          :computed-value
          :test (<code>lambda</code> (<var>marker</var>)
                  (<code>ecase</code> <var>marker</var>
                    (:full t)
                    (:empty nil)))
          :new-cachedp <code class="relevant marker">:full</code>)
  values)
-| (:EMPTY :PLACEHOLDER)
&rArr; (:FULL :COMPUTED-VALUE)</code></pre>
              </div>

            </section>
          </dd>
        </dl>

        <nav class="end-of-section-indicator">
          <a href="#cachef">
            "<span>cachef</span>" end.
          </a>
        </nav>

      </section>

      <section id="oldf">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#oldf" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-utils</a>
            <span class="crumb"><span class="s"> » </span><a class="here">oldf</a></span>
          </span>
        </h1>

        <p class="description">Make the storing form of a place return old value(s).</p>

        <dl>
          <dt><pre>Accessor Modifier <code class="relevant">oldf</code> <var>place</var></pre></dt>
          <dd>
            <p><code class="relevant">oldf</code> simply modifies the behavior of the storing form of <var>place</var> so that it returns the old values of the place instead of the new ones.</p>
            <div class="scroll">
              <pre class="example"><code class="common-lisp">(<code>let</code> ((<var>a</var> 5))
  (<code>values</code> (<code>incf</code> (<code class="relevant">oldf</code> <var>a</var>) 2)
          <var>a</var>))
&rArr; 5, 7</code></pre>
            </div>
            <div class="scroll">
              <pre class="example"><code class="common-lisp">(<code>let</code> ((<var>a</var> 5))
  (<code>values</code> (<code>setf</code> (<code class="relevant">oldf</code> <var>a</var>) 10)
          <var>a</var>))
&rArr; 5, 10</code></pre>
            </div>
            <div class="scroll">
              <pre class="example"><code class="common-lisp">(<code>let</code> ((<var>list</var> '(1 2 3)))
  (<code>values</code> (<code>push</code> 0 (<code class="relevant">oldf</code> <var>list</var>))
          <var>list</var>))
&rArr; (1 2 3), (0 1 2 3)</code></pre>
            </div>
          </dd>
        </dl>

      </section>

      <section id="readf">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#readf" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-utils</a>
            <span class="crumb"><span class="s"> » </span><a class="here">readf</a></span>
          </span>
        </h1>

        <p class="description">Easily make a place work in non-place contexts.</p>

        <dl>
          <dt><pre>Accessor Modifier <code class="relevant">readf</code> <var>place</var></pre></dt>
          <dd>
            <p>This is a most highly trivial accessor modifier useful to easily make a place work in non-place contexts.</p>
            <p>A recurring pattern is that you invent a new type of place modifier, so you define a new setf-expander. When the place modifier is called in a regular, non-place context, you just want to evaluate the subforms appropriately and then read the place.</p>
            <p>To use <code class="relevant">readf</code>, simply make a macro with the same name and parameters as the setf-expander. Expand to <code class="common-lisp">`(readf ,<var>whole</var>)</code>, where <var>whole</var> is the <var>&amp;whole</var> variable in your lambda list. (Don't worry, this doesn't result in an infinite recursive expansion.)</p>
            <p>(I'm still wondering if <code class="relevant">readf</code> makes any sense at all or if there's a much simpler way to do this... <code class="relevant">cachef</code>, <code class="relevant">oldf</code> and <code class="relevant">tracef</code> use it so there appears to be at least some marginal value...)</p>
          </dd>
        </dl>

      </section>

      <section id="tracef">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#tracef" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-utils</a>
            <span class="crumb"><span class="s"> » </span><a class="here">tracef</a></span>
          </span>
        </h1>

        <p class="description">Output debug info when a particular place is accessed.</p>

        <dl>
          <dt><pre>Accessor Modifier <code class="relevant">tracef</code> <var>place</var></pre></dt>
          <dd>
            <p><code class="relevant">tracef</code> returns the setf-expander of <var>place</var>, modified so that relevant debug information is printed (in an unspecified format) on <code>*trace-output*</code> as well as performing the normal behavior.</p>
            <p>Debug information is printed when a subform is evaluated and when the place is read from or written to.</p>
            <div class="scroll">
              <pre class="example"><code class="common-lisp">(let ((a (list 2)))
  (incf (tracef (car (print a)))
        3))
-| (2)
-| TRACEF: Place: (CAR (PRINT A))
-| TRACEF: Action: Evaluate Subform
-| TRACEF: Subform: (PRINT A)
-| TRACEF: Result: (2)
-|
-| TRACEF: Place: (CAR (PRINT A))
-| TRACEF: Action: Read
-| TRACEF: Values: (2)
-|
-| TRACEF: Place: (CAR (PRINT A))
-| TRACEF: Action: Write
-| TRACEF: Values: (5)
&rArr; 5
</code></pre>
            </div>
          </dd>
        </dl>

      </section>

    </main>

    <footer id="footer">
      <div class="back-to-top left">
        <a href="#">⬆</a>
      </div>
      <div class="main">
        <a href="https://validator.w3.org/check?uri=http%3A%2F%2Fwww.hexstreamsoft.com%2Flibraries%2Fplace-utils%2F">✔ HTML5</a>
        <a href="https://www.hexstreamsoft.com/README">✔ Public Domain</a>
        <a href="https://jigsaw.w3.org/css-validator/validator?uri=http%3A%2F%2Fwww.hexstreamsoft.com%2Flibraries%2Fplace-utils%2F">✔ CSS3</a>
        <a>✔ Mobile-friendly</a>
      </div>
      <div class="back-to-top right">
        <a href="#">⬆</a>
      </div>
    </footer>

  </body>
</html>
